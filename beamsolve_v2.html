<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BeamSolve — Interactive FEM Beam Analyzer</title>
<style>
  /* ===== RESET & BASE ===== */
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg-primary: #0F1117;
    --bg-secondary: #1A1D27;
    --bg-tertiary: #242836;
    --bg-hover: #2D3245;
    --border: #2E3348;
    --border-light: #3A4060;
    --text-primary: #F0F1F5;
    --text-secondary: #9BA1B8;
    --text-tertiary: #636A85;
    --accent: #6C8EFF;
    --accent-hover: #8BA5FF;
    --accent-muted: #3D4F8A;
    --success: #4ADE80;
    --warning: #FBBF24;
    --danger: #F87171;
    --info: #60A5FA;
    --beam-color: #8B95B0;
    --shear-color: #4ADE80;
    --moment-color: #F87171;
    --deflection-color: #FBBF24;
    --normal-color: #C084FC;
    --support-color: #60A5FA;
    --load-color: #F87171;
    --moment-load-color: #C084FC;
    --radius: 10px;
    --radius-sm: 6px;
    --font: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
  }

  html, body {
    height: 100%; width: 100%;
    font-family: var(--font);
    background: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
    font-size: 13px;
  }

  /* ===== LAYOUT ===== */
  #app {
    display: flex; flex-direction: column;
    height: 100vh; width: 100vw;
  }

  #toolbar {
    display: flex; align-items: center; gap: 6px;
    padding: 6px 16px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    z-index: 10;
    flex-wrap: wrap;
  }
  #toolbar .logo {
    font-size: 18px; font-weight: 700;
    color: var(--accent);
    margin-right: 4px;
  }
  #toolbar .subtitle {
    color: var(--text-secondary);
    font-size: 11px;
    margin-right: 12px;
  }
  #toolbar .sep {
    width: 1px; height: 24px;
    background: var(--border);
    margin: 0 6px;
  }
  .tb-btn {
    background: transparent;
    color: var(--text-secondary);
    border: 1px solid transparent;
    border-radius: var(--radius-sm);
    padding: 5px 12px;
    font-size: 11px;
    font-family: var(--font);
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }
  .tb-btn:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
    border-color: var(--border);
  }
  .tb-btn.active {
    background: var(--accent-muted);
    color: var(--accent);
    border-color: var(--accent);
  }
  .tb-spacer { flex: 1; }
  .tb-hint {
    color: var(--text-tertiary);
    font-size: 10px;
  }
  .snap-toggle {
    display: flex; align-items: center; gap: 4px;
    color: var(--text-secondary);
    font-size: 10px;
    cursor: pointer;
    user-select: none;
  }
  .snap-toggle input { accent-color: var(--accent); }

  #main {
    display: flex; flex: 1;
    overflow: hidden;
  }

  /* ===== CANVAS AREA ===== */
  #canvas-area {
    flex: 1;
    display: flex; flex-direction: column;
    overflow: hidden;
    position: relative;
  }

  canvas { display: block; width: 100%; cursor: default; }

  #beam-canvas { flex: 0 0 auto; min-height: 240px; }

  #diagram-area {
    flex: 1;
    display: flex; flex-direction: column;
    min-height: 0;
  }

  .diagram-label {
    position: absolute; left: 8px;
    font-size: 10px; font-weight: 600;
    color: var(--text-secondary);
    pointer-events: none; z-index: 2;
  }

  .diagram-wrapper {
    position: relative; flex: 1;
    min-height: 0;
    border-top: 1px solid var(--border);
  }
  .diagram-wrapper canvas { height: 100%; }

  /* ===== INLINE EDIT OVERLAY ===== */
  #inline-edit {
    position: fixed;
    display: none;
    z-index: 100;
  }
  #inline-edit input {
    background: var(--bg-tertiary);
    color: var(--text-primary);
    border: 2px solid var(--accent);
    border-radius: var(--radius-sm);
    padding: 4px 8px;
    font-size: 12px;
    font-family: var(--font);
    font-weight: 700;
    width: 90px;
    outline: none;
    text-align: center;
  }

  /* ===== SIDEBAR ===== */
  #sidebar {
    width: 300px;
    flex-shrink: 0;
    background: var(--bg-secondary);
    border-left: 1px solid var(--border);
    overflow-y: auto;
    overflow-x: hidden;
    padding: 14px;
    display: flex; flex-direction: column; gap: 12px;
  }
  #sidebar::-webkit-scrollbar { width: 6px; }
  #sidebar::-webkit-scrollbar-track { background: transparent; }
  #sidebar::-webkit-scrollbar-thumb { background: var(--border-light); border-radius: 3px; }

  .panel-title { font-size: 14px; font-weight: 600; margin-bottom: 2px; }

  .stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
  }
  .stat-card {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 8px 10px;
  }
  .stat-card .stat-label {
    font-size: 9px;
    color: var(--text-secondary);
    margin-bottom: 1px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .stat-card .stat-value { font-size: 14px; font-weight: 700; }

  .group {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 12px;
  }
  .group-title {
    font-size: 10px; font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
  }
  .form-row {
    display: flex; align-items: center; gap: 6px;
    margin-bottom: 6px;
  }
  .form-row:last-child { margin-bottom: 0; }
  .form-row label {
    font-size: 10px;
    color: var(--text-secondary);
    width: 55px;
    flex-shrink: 0;
  }
  .form-row input, .form-row select {
    flex: 1;
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 4px 6px;
    font-size: 11px;
    font-family: var(--font);
    outline: none;
    transition: border-color 0.15s;
    min-width: 0;
  }
  .form-row input:focus, .form-row select:focus { border-color: var(--accent); }
  .form-row .unit {
    font-size: 9px;
    color: var(--text-tertiary);
    width: 30px;
    flex-shrink: 0;
    text-align: right;
  }

  .btn {
    display: block; width: 100%;
    padding: 7px 10px;
    border: none;
    border-radius: var(--radius-sm);
    font-size: 11px; font-weight: 600;
    font-family: var(--font);
    cursor: pointer;
    transition: all 0.15s;
    margin-top: 6px;
  }
  .btn-primary { background: var(--accent); color: #fff; }
  .btn-primary:hover { background: var(--accent-hover); }
  .btn-danger {
    background: transparent;
    color: var(--danger);
    border: 1px solid var(--danger);
  }
  .btn-danger:hover { background: var(--danger); color: #fff; }

  .obj-list {
    display: flex; flex-direction: column; gap: 3px;
    margin-top: 6px;
    max-height: 220px;
    overflow-y: auto;
  }
  .obj-item {
    display: flex; align-items: center; gap: 5px;
    padding: 5px 8px;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 10px;
    flex-wrap: wrap;
  }
  .obj-item:hover { border-color: var(--border-light); }
  .obj-item .obj-icon {
    width: 7px; height: 7px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .obj-item .obj-text { flex: 1; min-width: 60px; }
  .obj-item .obj-del {
    color: var(--text-tertiary);
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    padding: 0 2px;
  }
  .obj-item .obj-del:hover { color: var(--danger); }
  .obj-item input, .obj-item select {
    background: var(--bg-primary);
    color: var(--text-primary);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 2px 4px;
    font-size: 10px;
    font-family: var(--font);
    outline: none;
  }
  .obj-item input:focus, .obj-item select:focus { border-color: var(--accent); }
  .obj-row2 {
    width: 100%;
    display: flex; gap: 4px; align-items: center;
    margin-top: 3px;
    padding-left: 12px;
  }
  .obj-row2 label {
    font-size: 9px; color: var(--text-tertiary);
    width: 30px; flex-shrink: 0;
  }

  #statusbar {
    display: flex; align-items: center; gap: 12px;
    padding: 3px 16px;
    background: var(--bg-secondary);
    border-top: 1px solid var(--border);
    font-size: 10px;
    color: var(--text-secondary);
    flex-shrink: 0;
  }
  #statusbar .status-spacer { flex: 1; }
</style>
</head>
<body>
<div id="app">

  <!-- TOOLBAR -->
  <div id="toolbar">
    <span class="logo">BeamSolve</span>
    <span class="subtitle">FEM Beam Analyzer</span>
    <div class="sep"></div>
    <button class="tb-btn" onclick="loadPreset('simply_supported')">Simply Supported</button>
    <button class="tb-btn" onclick="loadPreset('cantilever')">Cantilever</button>
    <button class="tb-btn" onclick="loadPreset('continuous')">Continuous</button>
    <button class="tb-btn" onclick="loadPreset('angled')">Angled Loads</button>
    <div class="sep"></div>
    <button class="tb-btn" id="btn-add-support" onclick="setTool('support')">+ Support</button>
    <button class="tb-btn" id="btn-add-load" onclick="setTool('load')">+ Point Load</button>
    <button class="tb-btn" id="btn-add-moment" onclick="setTool('moment')">+ Moment</button>
    <button class="tb-btn" id="btn-add-dist" onclick="setTool('distributed')">+ Distributed</button>
    <button class="tb-btn" id="btn-add-trap" onclick="setTool('trapezoid')">+ Trapezoid</button>
    <div class="sep"></div>
    <label class="snap-toggle">
      <input type="checkbox" id="snap-check" checked> Snap
    </label>
    <select id="snap-size" style="background:var(--bg-tertiary);color:var(--text-primary);border:1px solid var(--border);border-radius:4px;padding:2px 4px;font-size:10px;font-family:var(--font);outline:none;">
      <option value="50">50mm</option>
      <option value="100" selected>100mm</option>
      <option value="250">250mm</option>
      <option value="500">500mm</option>
    </select>
    <div class="tb-spacer"></div>
    <span class="tb-hint">Click to place — Drag to move — Dbl-click label to edit — Right-click to delete</span>
  </div>

  <!-- MAIN -->
  <div id="main">
    <div id="canvas-area">
      <canvas id="beam-canvas"></canvas>
      <div id="diagram-area">
        <div class="diagram-wrapper"><span class="diagram-label" style="top:4px;">Shear Force (V)</span><canvas id="shear-canvas"></canvas></div>
        <div class="diagram-wrapper"><span class="diagram-label" style="top:4px;">Bending Moment (M)</span><canvas id="moment-canvas"></canvas></div>
        <div class="diagram-wrapper"><span class="diagram-label" style="top:4px;">Normal Force (N)</span><canvas id="normal-canvas"></canvas></div>
        <div class="diagram-wrapper"><span class="diagram-label" style="top:4px;">Deflection (w)</span><canvas id="deflection-canvas"></canvas></div>
      </div>
    </div>

    <!-- SIDEBAR -->
    <div id="sidebar">
      <div class="panel-title">Results</div>
      <div class="stats-grid">
        <div class="stat-card"><div class="stat-label">Max Shear</div><div class="stat-value" id="stat-v" style="color:var(--shear-color)">—</div></div>
        <div class="stat-card"><div class="stat-label">Max Moment</div><div class="stat-value" id="stat-m" style="color:var(--moment-color)">—</div></div>
        <div class="stat-card"><div class="stat-label">Max Normal</div><div class="stat-value" id="stat-n" style="color:var(--normal-color)">—</div></div>
        <div class="stat-card"><div class="stat-label">Max Deflection</div><div class="stat-value" id="stat-w" style="color:var(--deflection-color)">—</div></div>
      </div>

      <div class="group">
        <div class="group-title">Beam Properties</div>
        <div class="form-row"><label>Length</label><input type="number" id="inp-length" value="5000" step="100" min="100"><span class="unit">mm</span></div>
        <div class="form-row"><label>E</label><input type="number" id="inp-E" value="210000" step="1000" min="1"><span class="unit">MPa</span></div>
        <div class="form-row"><label>I</label><input type="number" id="inp-I" value="83560000" step="100000" min="1"><span class="unit">mm⁴</span></div>
        <div class="form-row"><label>A</label><input type="number" id="inp-A" value="2850" step="100" min="1"><span class="unit">mm²</span></div>
        <button class="btn btn-primary" onclick="applyBeamProps()">Apply</button>
      </div>

      <div class="group">
        <div class="group-title">Supports</div>
        <div class="obj-list" id="support-list"></div>
      </div>

      <div class="group">
        <div class="group-title">Loads</div>
        <div class="obj-list" id="load-list"></div>
      </div>

      <button class="btn btn-danger" onclick="clearAll()">Clear All</button>
    </div>
  </div>

  <!-- INLINE EDIT OVERLAY -->
  <div id="inline-edit"><input type="text" id="inline-input"></div>

  <!-- STATUS BAR -->
  <div id="statusbar">
    <span id="status-text">Ready</span>
    <span class="status-spacer"></span>
    <span id="snap-status">Snap: 100mm</span>
    <span>|</span>
    <span>Method: Direct Stiffness (FEM)</span>
  </div>
</div>

<script>
// =============================================================================
// BeamSolve v2 — Complete Interactive FEM Beam Analyzer
// Features: Moments, Angled loads, Trapezoid loads, Normal forces,
//           Snap-to-grid, Inline editing, Draggable distributed loads
// =============================================================================

// ===== STATE =====
const state = {
  beam: { length: 5000, E: 210000, I: 83560000, A: 2850 },
  // Object types:
  //   support:     { type, x, subtype:'pinned'|'roller'|'fixed', _id }
  //   load:        { type, x, value (N, +down), angle (deg, 0=down, 90=right), _id }
  //   moment:      { type, x, value (N·mm, +CCW), _id }
  //   distributed: { type, x, x2, value (N/mm), _id }
  //   trapezoid:   { type, x, x2, value (start N/mm), value2 (end N/mm), _id }
  objects: [],
  result: null,
  tool: null,
  distStart: null,
};

let dragging = null;   // { index, part:'body'|'start'|'end', offsetX, origX?, origX2? }
let hovering = -1;
let hoverPart = null;  // 'body' | 'start' | 'end' | null

// ===== CANVAS REFS =====
const beamCanvas = document.getElementById('beam-canvas');
const shearCanvas = document.getElementById('shear-canvas');
const momentCanvas = document.getElementById('moment-canvas');
const normalCanvas = document.getElementById('normal-canvas');
const deflCanvas = document.getElementById('deflection-canvas');

const beamCtx = beamCanvas.getContext('2d');
const shearCtx = shearCanvas.getContext('2d');
const momentCtx = momentCanvas.getContext('2d');
const normalCtx = normalCanvas.getContext('2d');
const deflCtx = deflCanvas.getContext('2d');

// ===== CONSTANTS =====
const MARGIN_LEFT = 70;
const MARGIN_RIGHT = 40;
const BEAM_Y_RATIO = 0.48;
const BEAM_HEIGHT = 8;
const HIT_RADIUS = 16;
const HANDLE_HIT = 12;

// ===== SNAP =====
function snapEnabled() { return document.getElementById('snap-check').checked; }
function snapSize() { return parseInt(document.getElementById('snap-size').value) || 100; }
function snapValue(v) {
  if (!snapEnabled()) return v;
  const s = snapSize();
  return Math.round(v / s) * s;
}

document.getElementById('snap-check').addEventListener('change', () => {
  document.getElementById('snap-status').textContent = snapEnabled() ? 'Snap: ' + snapSize() + 'mm' : 'Snap: Off';
});
document.getElementById('snap-size').addEventListener('change', () => {
  document.getElementById('snap-status').textContent = 'Snap: ' + snapSize() + 'mm';
});

// ===== COORDINATE HELPERS =====
function getBeamPixelRange(canvas) {
  const dpr = window.devicePixelRatio || 1;
  return { left: MARGIN_LEFT, right: canvas.width / dpr - MARGIN_RIGHT };
}
function beamToPixelX(x, canvas) {
  const { left, right } = getBeamPixelRange(canvas);
  return left + (x / state.beam.length) * (right - left);
}
function pixelToBeamX(px, canvas) {
  const { left, right } = getBeamPixelRange(canvas);
  let bx = ((px - left) / (right - left)) * state.beam.length;
  return Math.max(0, Math.min(state.beam.length, bx));
}
function getBeamY(canvas) {
  const dpr = window.devicePixelRatio || 1;
  return (canvas.height / dpr) * BEAM_Y_RATIO;
}

// ===== ID =====
let _id_counter = 0;
function newId() { return '_' + (++_id_counter); }

// =============================================================================
// MATRIX MATH — LU Decomposition (vanilla JS)
// =============================================================================
function luSolve(A, b) {
  const n = A.length;
  const Ab = A.map(row => Float64Array.from(row));
  const bb = Float64Array.from(b);

  for (let k = 0; k < n; k++) {
    let maxVal = 0, maxIdx = k;
    for (let i = k; i < n; i++) {
      const v = Math.abs(Ab[i][k]);
      if (v > maxVal) { maxVal = v; maxIdx = i; }
    }
    if (maxVal < 1e-30) continue;
    if (maxIdx !== k) {
      [Ab[k], Ab[maxIdx]] = [Ab[maxIdx], Ab[k]];
      [bb[k], bb[maxIdx]] = [bb[maxIdx], bb[k]];
    }
    for (let i = k + 1; i < n; i++) {
      const factor = Ab[i][k] / Ab[k][k];
      Ab[i][k] = factor;
      for (let j = k + 1; j < n; j++) Ab[i][j] -= factor * Ab[k][j];
      bb[i] -= factor * bb[k];
    }
  }
  const x = new Float64Array(n);
  for (let i = n - 1; i >= 0; i--) {
    let sum = bb[i];
    for (let j = i + 1; j < n; j++) sum -= Ab[i][j] * x[j];
    x[i] = Math.abs(Ab[i][i]) > 1e-30 ? sum / Ab[i][i] : 0;
  }
  return x;
}

// =============================================================================
// FEM SOLVER — Direct Stiffness Method
// Now with: moments, angled loads, trapezoid loads, normal forces
// =============================================================================
function solveBeam() {
  const supports = state.objects.filter(o => o.type === 'support');
  const pointLoads = state.objects.filter(o => o.type === 'load');
  const moments = state.objects.filter(o => o.type === 'moment');
  const distLoads = state.objects.filter(o => o.type === 'distributed');
  const trapLoads = state.objects.filter(o => o.type === 'trapezoid');

  if (supports.length < 1) { state.result = null; return; }

  const L = state.beam.length;
  const EI = state.beam.E * state.beam.I;
  const EA = state.beam.E * state.beam.A;
  const nElem = 80;
  const nNodes = nElem + 1;
  // 3 DOFs per node: axial (u), vertical (w), rotation (theta)
  const nDof = 3 * nNodes;
  const Le = L / nElem;

  const K = Array.from({ length: nDof }, () => new Float64Array(nDof));
  const F = new Float64Array(nDof);

  // Beam element stiffness coefficients
  const coeffB = EI / (Le * Le * Le);
  const Le2 = Le * Le;
  const coeffA = EA / Le;

  for (let e = 0; e < nElem; e++) {
    // DOFs: [u_i, w_i, theta_i, u_j, w_j, theta_j]
    const d = [3*e, 3*e+1, 3*e+2, 3*e+3, 3*e+4, 3*e+5];

    // 6x6 element stiffness matrix (axial + bending)
    const ke = [
      [ coeffA,  0,             0,            -coeffA,  0,             0           ],
      [ 0,       12*coeffB,     6*Le*coeffB,   0,      -12*coeffB,    6*Le*coeffB  ],
      [ 0,       6*Le*coeffB,   4*Le2*coeffB,  0,      -6*Le*coeffB,  2*Le2*coeffB ],
      [-coeffA,  0,             0,             coeffA,  0,             0           ],
      [ 0,      -12*coeffB,    -6*Le*coeffB,   0,       12*coeffB,   -6*Le*coeffB  ],
      [ 0,       6*Le*coeffB,   2*Le2*coeffB,  0,      -6*Le*coeffB,  4*Le2*coeffB ],
    ];
    for (let r = 0; r < 6; r++)
      for (let c = 0; c < 6; c++)
        K[d[r]][d[c]] += ke[r][c];
  }

  // --- Apply point loads (with angle decomposition) ---
  for (const pl of pointLoads) {
    const angle = (pl.angle || 0) * Math.PI / 180; // 0=down, 90=right
    const Fv = pl.value * Math.cos(angle);  // Vertical component (positive = down)
    const Fh = pl.value * Math.sin(angle);  // Horizontal component (positive = right)

    // Vertical component → beam bending DOFs
    const eIdx = Math.min(Math.floor(pl.x / Le), nElem - 1);
    const a = pl.x - eIdx * Le;
    const b = Le - a;
    const d = [3*eIdx+1, 3*eIdx+2, 3*eIdx+4, 3*eIdx+5];
    const feq = [
      Fv * b*b * (3*a + b) / (Le*Le*Le),
      Fv * a * b*b / (Le*Le),
      Fv * a*a * (a + 3*b) / (Le*Le*Le),
     -Fv * a*a * b / (Le*Le),
    ];
    for (let r = 0; r < 4; r++) F[d[r]] += feq[r];

    // Horizontal component → axial DOFs
    if (Math.abs(Fh) > 1e-10) {
      const xi = a / Le;
      const nodeI = 3 * eIdx;     // u DOF of left node
      const nodeJ = 3 * eIdx + 3; // u DOF of right node
      F[nodeI] += Fh * (1 - xi);
      F[nodeJ] += Fh * xi;
    }
  }

  // --- Apply moment loads ---
  for (const ml of moments) {
    const eIdx = Math.min(Math.floor(ml.x / Le), nElem - 1);
    const a = ml.x - eIdx * Le;
    const b = Le - a;
    const M = ml.value;
    const d = [3*eIdx+1, 3*eIdx+2, 3*eIdx+4, 3*eIdx+5];
    const feq = [
      -6 * M * a * b / (Le*Le*Le),
       M * b * (2*a - b) / (Le*Le),
       6 * M * a * b / (Le*Le*Le),
       M * a * (2*b - a) / (Le*Le),
    ];
    for (let r = 0; r < 4; r++) F[d[r]] += feq[r];
  }

  // --- Apply uniform distributed loads ---
  for (const dl of distLoads) {
    applyDistLoad(F, dl.x, dl.x2, dl.value, dl.value, Le, nElem);
  }

  // --- Apply trapezoid loads ---
  for (const tl of trapLoads) {
    applyDistLoad(F, tl.x, tl.x2, tl.value, tl.value2, Le, nElem);
  }

  // --- Boundary conditions ---
  const constrained = new Set();
  const supNodeMap = {};

  for (const sup of supports) {
    const node = Math.round(sup.x / Le);
    const cn = Math.max(0, Math.min(nNodes - 1, node));
    const uDof = 3 * cn;     // axial
    const wDof = 3 * cn + 1; // vertical
    const tDof = 3 * cn + 2; // rotation

    // All supports constrain vertical displacement
    constrained.add(wDof);
    if (!supNodeMap[sup._id]) supNodeMap[sup._id] = [];
    supNodeMap[sup._id].push(wDof);

    if (sup.subtype === 'pinned') {
      // Also constrain axial
      constrained.add(uDof);
      supNodeMap[sup._id].push(uDof);
    } else if (sup.subtype === 'fixed') {
      constrained.add(uDof);
      constrained.add(tDof);
      supNodeMap[sup._id].push(uDof);
      supNodeMap[sup._id].push(tDof);
    }
    // Roller: only vertical constrained (already added)
  }

  const freeArr = [];
  for (let i = 0; i < nDof; i++) {
    if (!constrained.has(i)) freeArr.push(i);
  }
  if (freeArr.length === 0) { state.result = null; return; }

  // --- Solve ---
  const nf = freeArr.length;
  const Kff = Array.from({ length: nf }, () => new Float64Array(nf));
  const Ff = new Float64Array(nf);
  for (let i = 0; i < nf; i++) {
    Ff[i] = F[freeArr[i]];
    for (let j = 0; j < nf; j++) Kff[i][j] = K[freeArr[i]][freeArr[j]];
  }

  const uf = luSolve(Kff, Ff);
  const u = new Float64Array(nDof);
  for (let i = 0; i < nf; i++) u[freeArr[i]] = uf[i];

  // --- Reactions ---
  const reactions = {};
  const Ku = new Float64Array(nDof);
  for (let i = 0; i < nDof; i++) {
    let s = 0;
    for (let j = 0; j < nDof; j++) s += K[i][j] * u[j];
    Ku[i] = s;
  }
  for (const sup of supports) {
    if (supNodeMap[sup._id]) {
      let rv = 0, rh = 0;
      for (const dof of supNodeMap[sup._id]) {
        const r = Ku[dof] - F[dof];
        if (dof % 3 === 1) rv += r;      // vertical
        else if (dof % 3 === 0) rh += r;  // horizontal
      }
      reactions[sup._id] = { v: rv, h: rh };
    }
  }

  // --- Extract nodal results ---
  const xArr = new Float64Array(nNodes);
  const uAxial = new Float64Array(nNodes);
  const wArr = new Float64Array(nNodes);
  const thetaArr = new Float64Array(nNodes);
  for (let i = 0; i < nNodes; i++) {
    xArr[i] = i * Le;
    uAxial[i] = u[3*i];
    wArr[i] = u[3*i + 1];
    thetaArr[i] = u[3*i + 2];
  }

  // --- Internal forces (N, V, M) ---
  const N = new Float64Array(nNodes);
  const V = new Float64Array(nNodes);
  const M = new Float64Array(nNodes);

  for (let e = 0; e < nElem; e++) {
    const d = [3*e, 3*e+1, 3*e+2, 3*e+3, 3*e+4, 3*e+5];
    const ue = d.map(i => u[i]);

    const ke = [
      [ coeffA,  0,             0,            -coeffA,  0,             0           ],
      [ 0,       12*coeffB,     6*Le*coeffB,   0,      -12*coeffB,    6*Le*coeffB  ],
      [ 0,       6*Le*coeffB,   4*Le2*coeffB,  0,      -6*Le*coeffB,  2*Le2*coeffB ],
      [-coeffA,  0,             0,             coeffA,  0,             0           ],
      [ 0,      -12*coeffB,    -6*Le*coeffB,   0,       12*coeffB,   -6*Le*coeffB  ],
      [ 0,       6*Le*coeffB,   2*Le2*coeffB,  0,      -6*Le*coeffB,  4*Le2*coeffB ],
    ];

    const fe = [0,0,0,0,0,0];
    for (let r = 0; r < 6; r++)
      for (let c = 0; c < 6; c++)
        fe[r] += ke[r][c] * ue[c];

    // Normal force (axial)
    if (e === 0) N[0] = fe[0];
    N[e + 1] = -fe[3];

    // Shear and moment
    if (e === 0) {
      V[0] = fe[1];
      M[0] = -fe[2];
    }
    V[e + 1] = -fe[4];
    M[e + 1] = fe[5];
  }

  state.result = {
    x: xArr, uAxial, w: wArr, theta: thetaArr,
    N, V, M, reactions,
    maxN: Math.max(...Array.from(N).map(Math.abs)),
    maxV: Math.max(...Array.from(V).map(Math.abs)),
    maxM: Math.max(...Array.from(M).map(Math.abs)),
    maxW: Math.max(...Array.from(wArr).map(Math.abs)),
  };
}

// --- Helper: apply linearly varying distributed load (trapezoid) ---
function applyDistLoad(F, xStart, xEnd, qStart, qEnd, Le, nElem) {
  const startE = Math.max(0, Math.floor(xStart / Le));
  const endE = Math.min(nElem - 1, Math.ceil(xEnd / Le) - 1);
  const totalLen = xEnd - xStart;

  for (let e = startE; e <= endE; e++) {
    const xL = e * Le;
    const xR = (e + 1) * Le;
    const xs = Math.max(xL, xStart);
    const xe = Math.min(xR, xEnd);
    if (xe <= xs) continue;

    const d = [3*e+1, 3*e+2, 3*e+4, 3*e+5]; // w and theta DOFs

    // 4-point Gauss quadrature for linearly varying load
    const gp = [-0.861136, -0.339981, 0.339981, 0.861136];
    const gw = [0.347855, 0.652145, 0.652145, 0.347855];
    const mid = (xs + xe) / 2 - xL;
    const halfLen = (xe - xs) / 2;

    for (let g = 0; g < 4; g++) {
      const xloc = mid + halfLen * gp[g]; // local coord in element
      const xGlobal = xL + xloc;
      const xi = xloc / Le;

      // Interpolate load magnitude at this point
      const t = totalLen > 1e-10 ? (xGlobal - xStart) / totalLen : 0;
      const q = qStart + (qEnd - qStart) * t;

      const Nshape = [
        1 - 3*xi*xi + 2*xi*xi*xi,
        Le * xi * (1 - xi) * (1 - xi),
        3*xi*xi - 2*xi*xi*xi,
        Le * xi*xi * (xi - 1),
      ];
      for (let r = 0; r < 4; r++) F[d[r]] += q * Nshape[r] * halfLen * gw[g];
    }
  }
}

// =============================================================================
// RENDERING
// =============================================================================
function resizeCanvases() {
  const area = document.getElementById('canvas-area');
  const dpr = window.devicePixelRatio || 1;
  const totalW = area.clientWidth;

  const beamH = 240;
  beamCanvas.width = totalW * dpr;
  beamCanvas.height = beamH * dpr;
  beamCanvas.style.height = beamH + 'px';
  beamCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const diagArea = document.getElementById('diagram-area');
  const diagH = diagArea.clientHeight;
  const nDiag = 4;
  const singleH = Math.floor(diagH / nDiag);

  [shearCanvas, momentCanvas, normalCanvas, deflCanvas].forEach((c, i) => {
    const h = (i < nDiag - 1) ? singleH : diagH - (nDiag - 1) * singleH;
    c.width = totalW * dpr;
    c.height = Math.max(h, 40) * dpr;
    c.style.height = Math.max(h, 40) + 'px';
    c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
  });
}

function renderAll() {
  renderBeam();
  renderDiagram(shearCtx, shearCanvas, state.result?.V, state.result?.x, '#4ADE80', 'rgba(74,222,128,0.12)', 'N');
  renderDiagram(momentCtx, momentCanvas, state.result?.M, state.result?.x, '#F87171', 'rgba(248,113,113,0.12)', 'N·mm');
  renderDiagram(normalCtx, normalCanvas, state.result?.N, state.result?.x, '#C084FC', 'rgba(192,132,252,0.12)', 'N');
  renderDiagram(deflCtx, deflCanvas, state.result?.w, state.result?.x, '#FBBF24', 'rgba(251,191,36,0.12)', 'mm');
  updateStats();
  updateObjectLists();
}

const _font = getComputedStyle(document.body).fontFamily;

function renderBeam() {
  const c = beamCanvas;
  const ctx = beamCtx;
  const dpr = window.devicePixelRatio || 1;
  const w = c.width / dpr;
  const h = c.height / dpr;
  ctx.clearRect(0, 0, w, h);

  const { left, right } = getBeamPixelRange(c);
  const by = getBeamY(c);

  // Grid (with snap lines highlighted)
  const sSize = snapSize();
  for (let gx = 0; gx < w; gx += 50) {
    ctx.strokeStyle = '#1E2235'; ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, h); ctx.stroke();
  }
  for (let gy = 0; gy < h; gy += 50) {
    ctx.strokeStyle = '#1E2235'; ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
  }

  // Snap grid lines on beam
  if (snapEnabled()) {
    ctx.strokeStyle = 'rgba(108,142,255,0.08)';
    ctx.lineWidth = 1;
    for (let mm = 0; mm <= state.beam.length; mm += sSize) {
      const px = beamToPixelX(mm, c);
      ctx.beginPath(); ctx.moveTo(px, by - 30); ctx.lineTo(px, by + 30); ctx.stroke();
    }
  }

  // Axis line
  ctx.strokeStyle = '#3A4060'; ctx.lineWidth = 0.5;
  ctx.setLineDash([4, 4]);
  ctx.beginPath(); ctx.moveTo(left - 15, by); ctx.lineTo(right + 15, by); ctx.stroke();
  ctx.setLineDash([]);

  // Deflection curve
  if (state.result && state.result.w) {
    const { x: xArr, w: wArr, maxW } = state.result;
    if (maxW > 1e-15) {
      const scale = 50 / maxW;
      ctx.beginPath();
      for (let i = 0; i < xArr.length; i++) {
        const px = beamToPixelX(xArr[i], c);
        const py = by + wArr[i] * scale;
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.strokeStyle = '#6C8EFF'; ctx.lineWidth = 2.5;
      ctx.lineJoin = 'round'; ctx.lineCap = 'round';
      ctx.stroke();
    }
  }

  // Beam body
  const grad = ctx.createLinearGradient(0, by - BEAM_HEIGHT/2, 0, by + BEAM_HEIGHT/2);
  grad.addColorStop(0, '#9BA5C0'); grad.addColorStop(1, '#6B7394');
  ctx.fillStyle = grad;
  roundRect(ctx, left, by - BEAM_HEIGHT/2, right - left, BEAM_HEIGHT, 3);
  ctx.fill();

  // Dimension line
  const dimY = by + 65;
  ctx.strokeStyle = '#636A85'; ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(left, dimY); ctx.lineTo(right, dimY);
  ctx.moveTo(left, dimY - 4); ctx.lineTo(left, dimY + 4);
  ctx.moveTo(right, dimY - 4); ctx.lineTo(right, dimY + 4);
  ctx.stroke();
  ctx.fillStyle = '#636A85'; ctx.font = '10px ' + _font; ctx.textAlign = 'center';
  ctx.fillText(state.beam.length + ' mm', (left + right) / 2, dimY + 14);

  // Draw objects in order: distributed/trapezoid → supports → loads → moments
  for (let i = 0; i < state.objects.length; i++) {
    const obj = state.objects[i];
    if (obj.type === 'distributed') drawDistributedLoad(ctx, c, obj, by, i);
    if (obj.type === 'trapezoid') drawTrapezoidLoad(ctx, c, obj, by, i);
  }
  for (let i = 0; i < state.objects.length; i++) {
    const obj = state.objects[i];
    if (obj.type === 'support') drawSupport(ctx, c, obj, by, i === hovering);
  }
  for (let i = 0; i < state.objects.length; i++) {
    const obj = state.objects[i];
    if (obj.type === 'load') drawPointLoad(ctx, c, obj, by, i === hovering);
    if (obj.type === 'moment') drawMomentLoad(ctx, c, obj, by, i === hovering);
  }

  // Reaction forces
  if (state.result && state.result.reactions) {
    ctx.font = 'bold 9px ' + _font; ctx.textAlign = 'center';
    for (const sup of state.objects.filter(o => o.type === 'support')) {
      const r = state.result.reactions[sup._id];
      if (r) {
        const px = beamToPixelX(sup.x, c);
        ctx.fillStyle = 'rgba(96,165,250,0.7)';
        let label = 'Rv=' + formatForce(Math.abs(r.v));
        if (Math.abs(r.h) > 0.01) label += '  Rh=' + formatForce(Math.abs(r.h));
        ctx.fillText(label, px, by + 50);
      }
    }
  }

  // Tool hint
  if (state.tool) {
    ctx.fillStyle = 'rgba(108,142,255,0.12)';
    roundRect(ctx, left, by - 55, right - left, 110, 6); ctx.fill();
    ctx.fillStyle = '#6C8EFF'; ctx.font = '12px ' + _font; ctx.textAlign = 'center';
    const hints = {
      support: 'Click on the beam to place a support',
      load: 'Click on the beam to place a point load',
      moment: 'Click on the beam to place a moment',
      distributed: state.distStart === null ? 'Click START position' : 'Click END position',
      trapezoid: state.distStart === null ? 'Click START position' : 'Click END position',
    };
    ctx.fillText(hints[state.tool] || '', (left + right) / 2, by - 62 + 6);
  }
}

// ===== DRAWING FUNCTIONS =====
function drawSupport(ctx, canvas, sup, by, isHover) {
  const px = beamToPixelX(sup.x, canvas);
  const size = isHover ? 22 : 18;
  const color = isHover ? '#8BA5FF' : '#60A5FA';
  ctx.save(); ctx.translate(px, by);

  if (sup.subtype === 'fixed') {
    ctx.strokeStyle = color; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(0, -18); ctx.lineTo(0, 18); ctx.stroke();
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 6; i++) {
      const yh = -18 + i * 7.2;
      ctx.beginPath(); ctx.moveTo(0, yh); ctx.lineTo(-8, yh + 5); ctx.stroke();
    }
  } else {
    ctx.beginPath(); ctx.moveTo(0, 0);
    ctx.lineTo(-size/2, size*0.85); ctx.lineTo(size/2, size*0.85); ctx.closePath();
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    ctx.fillStyle = isHover ? 'rgba(96,165,250,0.15)' : 'rgba(96,165,250,0.06)';
    ctx.fill(); ctx.stroke();
    let baseY = size * 0.85 + 3;
    if (sup.subtype === 'roller') {
      ctx.beginPath(); ctx.arc(0, size*0.85+6, 4, 0, Math.PI*2);
      ctx.fillStyle = color; ctx.fill();
      baseY = size * 0.85 + 12;
    }
    ctx.strokeStyle = color; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(-size/2-3, baseY); ctx.lineTo(size/2+3, baseY); ctx.stroke();
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
      const xh = -size/2-3 + i*(size+6)/4;
      ctx.beginPath(); ctx.moveTo(xh, baseY); ctx.lineTo(xh-5, baseY+6); ctx.stroke();
    }
  }
  ctx.restore();
}

function drawPointLoad(ctx, canvas, load, by, isHover) {
  const px = beamToPixelX(load.x, canvas);
  const angle = (load.angle || 0) * Math.PI / 180;
  const arrowLen = 60;
  const color = isHover ? '#FCA5A5' : '#F87171';

  ctx.save(); ctx.translate(px, by);

  if (Math.abs(load.angle || 0) < 0.1) {
    // Pure vertical
    const dir = load.value > 0 ? 1 : -1;
    ctx.strokeStyle = color; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(0, -dir*arrowLen); ctx.lineTo(0, 0); ctx.stroke();
    const hs = 8;
    ctx.fillStyle = color; ctx.beginPath();
    ctx.moveTo(0, 0); ctx.lineTo(-hs/2, -dir*hs); ctx.lineTo(hs/2, -dir*hs); ctx.closePath(); ctx.fill();
  } else {
    // Angled arrow
    const endX = 0, endY = 0;
    const startX = -arrowLen * Math.sin(angle);
    const startY = -(load.value > 0 ? 1 : -1) * arrowLen * Math.cos(angle);

    ctx.strokeStyle = color; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke();

    // Arrowhead
    const dx = endX - startX, dy = endY - startY;
    const len = Math.sqrt(dx*dx + dy*dy);
    const ux = dx/len, uy = dy/len;
    const hs = 8;
    ctx.fillStyle = color; ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - ux*hs - uy*hs/2, endY - uy*hs + ux*hs/2);
    ctx.lineTo(endX - ux*hs + uy*hs/2, endY - uy*hs - ux*hs/2);
    ctx.closePath(); ctx.fill();

    // Angle arc
    ctx.strokeStyle = 'rgba(248,113,113,0.4)'; ctx.lineWidth = 1;
    ctx.beginPath();
    const arcR = 20;
    const baseAngle = load.value > 0 ? -Math.PI/2 : Math.PI/2;
    ctx.arc(0, 0, arcR, baseAngle, baseAngle + angle, angle < 0);
    ctx.stroke();
    ctx.fillStyle = 'rgba(248,113,113,0.5)'; ctx.font = '8px ' + _font; ctx.textAlign = 'left';
    ctx.fillText((load.angle||0).toFixed(0) + '°', arcR + 3, -5);
  }

  // Label
  ctx.fillStyle = color; ctx.font = 'bold 10px ' + _font; ctx.textAlign = 'center';
  const label = formatForce(Math.abs(load.value));
  const dir = load.value > 0 ? 1 : -1;
  ctx.fillText(label, 0, -dir * arrowLen - 8 * dir);

  ctx.restore();
}

function drawMomentLoad(ctx, canvas, ml, by, isHover) {
  const px = beamToPixelX(ml.x, canvas);
  const color = isHover ? '#D8B4FE' : '#C084FC';
  const r = 18;
  const dir = ml.value > 0 ? 1 : -1; // +CCW

  ctx.save(); ctx.translate(px, by);

  // Arc
  ctx.strokeStyle = color; ctx.lineWidth = 2.5;
  ctx.beginPath();
  const startA = -Math.PI * 0.8;
  const endA = Math.PI * 0.5;
  ctx.arc(0, 0, r, startA, endA, dir < 0);
  ctx.stroke();

  // Arrowhead at end of arc
  const tipAngle = dir > 0 ? endA : startA;
  const tx = r * Math.cos(tipAngle);
  const ty = r * Math.sin(tipAngle);
  const tangentAngle = tipAngle + (dir > 0 ? Math.PI/2 : -Math.PI/2);
  const hs = 7;
  ctx.fillStyle = color; ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(tx - hs * Math.cos(tangentAngle) - hs/2 * Math.sin(tangentAngle),
             ty - hs * Math.sin(tangentAngle) + hs/2 * Math.cos(tangentAngle));
  ctx.lineTo(tx - hs * Math.cos(tangentAngle) + hs/2 * Math.sin(tangentAngle),
             ty - hs * Math.sin(tangentAngle) - hs/2 * Math.cos(tangentAngle));
  ctx.closePath(); ctx.fill();

  // Label
  ctx.fillStyle = color; ctx.font = 'bold 10px ' + _font; ctx.textAlign = 'center';
  const absVal = Math.abs(ml.value);
  let label;
  if (absVal >= 1e6) label = (absVal/1e6).toFixed(1) + ' kN·m';
  else if (absVal >= 1e3) label = (absVal/1e3).toFixed(1) + ' N·m';
  else label = absVal.toFixed(0) + ' N·mm';
  ctx.fillText(label, 0, -r - 8);

  ctx.restore();
}

function drawDistributedLoad(ctx, canvas, dl, by, idx) {
  const pxS = beamToPixelX(dl.x, canvas);
  const pxE = beamToPixelX(dl.x2, canvas);
  const dir = dl.value > 0 ? 1 : -1;
  const arrowLen = 48;
  const color = '#F87171';
  const isH = (idx === hovering);

  ctx.save(); ctx.translate(0, by);

  ctx.fillStyle = isH ? 'rgba(248,113,113,0.12)' : 'rgba(248,113,113,0.06)';
  ctx.fillRect(pxS, 0, pxE - pxS, -dir * arrowLen);

  ctx.strokeStyle = color; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(pxS, -dir*arrowLen); ctx.lineTo(pxE, -dir*arrowLen); ctx.stroke();

  const nArr = Math.max(3, Math.round((pxE - pxS) / 28));
  const hs = 6;
  for (let i = 0; i <= nArr; i++) {
    const ax = pxS + i * (pxE - pxS) / nArr;
    ctx.strokeStyle = color; ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.moveTo(ax, -dir*arrowLen); ctx.lineTo(ax, 0); ctx.stroke();
    ctx.fillStyle = color; ctx.beginPath();
    ctx.moveTo(ax, 0); ctx.lineTo(ax-hs/2, -dir*hs); ctx.lineTo(ax+hs/2, -dir*hs); ctx.closePath(); ctx.fill();
  }

  // Handles (start/end)
  if (isH) {
    ctx.fillStyle = '#FCA5A5';
    ctx.beginPath(); ctx.arc(pxS, -dir*arrowLen/2, 5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(pxE, -dir*arrowLen/2, 5, 0, Math.PI*2); ctx.fill();
  }

  ctx.fillStyle = color; ctx.font = 'bold 10px ' + _font; ctx.textAlign = 'center';
  ctx.fillText(Math.abs(dl.value).toFixed(1) + ' N/mm', (pxS+pxE)/2, -dir*arrowLen - 8*dir);

  ctx.restore();
}

function drawTrapezoidLoad(ctx, canvas, tl, by, idx) {
  const pxS = beamToPixelX(tl.x, canvas);
  const pxE = beamToPixelX(tl.x2, canvas);
  const maxMag = Math.max(Math.abs(tl.value), Math.abs(tl.value2), 0.01);
  const arrowLenMax = 55;
  const hS = (Math.abs(tl.value) / maxMag) * arrowLenMax;
  const hE = (Math.abs(tl.value2) / maxMag) * arrowLenMax;
  const dirS = tl.value >= 0 ? 1 : -1;
  const dirE = tl.value2 >= 0 ? 1 : -1;
  const color = '#F87171';
  const isH = (idx === hovering);

  ctx.save(); ctx.translate(0, by);

  // Hatched fill (trapezoid shape)
  ctx.beginPath();
  ctx.moveTo(pxS, 0);
  ctx.lineTo(pxS, -dirS * hS);
  // Top line (linear)
  const nPts = 20;
  for (let i = 1; i <= nPts; i++) {
    const t = i / nPts;
    const px = pxS + t * (pxE - pxS);
    const hh = hS + t * (hE - hS);
    const dd = dirS + t * (dirE - dirS);
    ctx.lineTo(px, -dd * hh);
  }
  ctx.lineTo(pxE, 0);
  ctx.closePath();
  ctx.fillStyle = isH ? 'rgba(248,113,113,0.12)' : 'rgba(248,113,113,0.06)';
  ctx.fill();

  // Hatching lines inside the trapezoid
  ctx.strokeStyle = 'rgba(248,113,113,0.2)';
  ctx.lineWidth = 0.8;
  const hatchSpacing = 8;
  const totalPx = pxE - pxS;
  for (let d = hatchSpacing; d < totalPx + arrowLenMax; d += hatchSpacing) {
    // Diagonal lines from bottom-left to top-right
    const x1 = pxS + d;
    const x2 = pxS + d - arrowLenMax * 0.7;
    if (x1 < pxS && x2 < pxS) continue;
    if (x1 > pxE + arrowLenMax && x2 > pxE + arrowLenMax) continue;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(pxS, 0);
    ctx.lineTo(pxS, -dirS * hS);
    for (let i = 1; i <= nPts; i++) {
      const t = i / nPts;
      const px = pxS + t * (pxE - pxS);
      const hh = hS + t * (hE - hS);
      const dd = dirS + t * (dirE - dirS);
      ctx.lineTo(px, -dd * hh);
    }
    ctx.lineTo(pxE, 0);
    ctx.closePath();
    ctx.clip();

    ctx.beginPath();
    ctx.moveTo(Math.max(pxS, x2), 0);
    ctx.lineTo(Math.min(pxE, x1), -arrowLenMax * 0.7);
    ctx.stroke();
    ctx.restore();
  }

  // Outline
  ctx.strokeStyle = color; ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(pxS, 0); ctx.lineTo(pxS, -dirS * hS);
  for (let i = 1; i <= nPts; i++) {
    const t = i / nPts;
    const px = pxS + t * (pxE - pxS);
    const hh = hS + t * (hE - hS);
    const dd = dirS + t * (dirE - dirS);
    ctx.lineTo(px, -dd * hh);
  }
  ctx.lineTo(pxE, 0);
  ctx.stroke();

  // Arrows
  const nArr = Math.max(3, Math.round((pxE - pxS) / 30));
  const ahs = 5;
  for (let i = 0; i <= nArr; i++) {
    const t = i / nArr;
    const ax = pxS + t * (pxE - pxS);
    const ah = hS + t * (hE - hS);
    const ad = dirS + t * (dirE - dirS);
    if (ah < 3) continue;
    ctx.strokeStyle = color; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(ax, -ad * ah); ctx.lineTo(ax, 0); ctx.stroke();
    ctx.fillStyle = color; ctx.beginPath();
    ctx.moveTo(ax, 0); ctx.lineTo(ax-ahs/2, -ad*ahs); ctx.lineTo(ax+ahs/2, -ad*ahs); ctx.closePath(); ctx.fill();
  }

  // Handles
  if (isH) {
    ctx.fillStyle = '#FCA5A5';
    ctx.beginPath(); ctx.arc(pxS, -dirS*hS/2, 5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(pxE, -dirE*hE/2, 5, 0, Math.PI*2); ctx.fill();
  }

  // Labels
  ctx.fillStyle = color; ctx.font = 'bold 9px ' + _font;
  ctx.textAlign = 'left';
  ctx.fillText(Math.abs(tl.value).toFixed(1), pxS + 3, -dirS * hS - 6);
  ctx.textAlign = 'right';
  ctx.fillText(Math.abs(tl.value2).toFixed(1) + ' N/mm', pxE - 3, -dirE * hE - 6);

  ctx.restore();
}

function renderDiagram(ctx, canvas, yData, xData, lineColor, fillColor, unit) {
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.width / dpr;
  const h = canvas.height / dpr;
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = '#1A1D27'; ctx.fillRect(0, 0, w, h);

  const { left, right } = getBeamPixelRange(canvas);
  const plotTop = 18, plotBottom = h - 10;
  const plotH = plotBottom - plotTop;
  const zeroY = plotTop + plotH / 2;

  ctx.strokeStyle = '#3A4060'; ctx.lineWidth = 0.8;
  ctx.setLineDash([3, 3]);
  ctx.beginPath(); ctx.moveTo(left, zeroY); ctx.lineTo(right, zeroY); ctx.stroke();
  ctx.setLineDash([]);

  if (!yData || !xData || xData.length < 2) return;

  const maxAbs = Math.max(...Array.from(yData).map(Math.abs), 1e-15);
  const scale = (plotH / 2) * 0.82 / maxAbs;

  ctx.beginPath();
  ctx.moveTo(beamToPixelX(xData[0], canvas), zeroY);
  for (let i = 0; i < xData.length; i++)
    ctx.lineTo(beamToPixelX(xData[i], canvas), zeroY - yData[i] * scale);
  ctx.lineTo(beamToPixelX(xData[xData.length-1], canvas), zeroY);
  ctx.closePath();
  ctx.fillStyle = fillColor; ctx.fill();

  ctx.beginPath();
  for (let i = 0; i < xData.length; i++) {
    const px = beamToPixelX(xData[i], canvas);
    const py = zeroY - yData[i] * scale;
    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.strokeStyle = lineColor; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.stroke();

  // Max annotation
  let maxIdx = 0, maxVal = 0;
  for (let i = 0; i < yData.length; i++)
    if (Math.abs(yData[i]) > Math.abs(maxVal)) { maxVal = yData[i]; maxIdx = i; }
  if (Math.abs(maxVal) > 1e-15) {
    const mpx = beamToPixelX(xData[maxIdx], canvas);
    const mpy = zeroY - yData[maxIdx] * scale;
    ctx.fillStyle = lineColor; ctx.beginPath(); ctx.arc(mpx, mpy, 3, 0, Math.PI*2); ctx.fill();
    ctx.font = 'bold 9px ' + _font;
    ctx.textAlign = mpx > (left+right)/2 ? 'right' : 'left';
    const off = mpx > (left+right)/2 ? -8 : 8;
    ctx.fillText(formatValue(maxVal) + ' ' + unit, mpx + off, mpy - 6);
  }

  ctx.fillStyle = '#636A85'; ctx.font = '9px ' + _font; ctx.textAlign = 'right';
  for (const frac of [-1, 0, 1]) {
    const val = frac * maxAbs;
    const py = zeroY - val * scale;
    ctx.fillText(formatValue(val), left - 6, py + 3);
  }
}

// ===== HELPERS =====
function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r); ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h); ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r); ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y); ctx.closePath();
}

function formatValue(v) {
  const a = Math.abs(v);
  if (a >= 1e9) return (v/1e9).toFixed(1)+'G';
  if (a >= 1e6) return (v/1e6).toFixed(1)+'M';
  if (a >= 1e3) return (v/1e3).toFixed(1)+'k';
  if (a >= 1) return v.toFixed(1);
  if (a >= 0.001) return v.toFixed(3);
  return v.toExponential(1);
}

function formatForce(v) {
  if (v >= 1e6) return (v/1e6).toFixed(2)+' MN';
  if (v >= 1e3) return (v/1e3).toFixed(2)+' kN';
  return v.toFixed(0)+' N';
}

// =============================================================================
// INTERACTION
// =============================================================================
function hitTest(mx, my, canvas) {
  const by = getBeamY(canvas);
  // Check distributed/trapezoid handles first
  for (let i = state.objects.length - 1; i >= 0; i--) {
    const obj = state.objects[i];
    if (obj.type === 'distributed' || obj.type === 'trapezoid') {
      const pxS = beamToPixelX(obj.x, canvas);
      const pxE = beamToPixelX(obj.x2, canvas);
      const midY = by - 24;
      // Start handle
      if (Math.abs(mx - pxS) < HANDLE_HIT && Math.abs(my - midY) < HANDLE_HIT + 20) {
        return { index: i, part: 'start' };
      }
      // End handle
      if (Math.abs(mx - pxE) < HANDLE_HIT && Math.abs(my - midY) < HANDLE_HIT + 20) {
        return { index: i, part: 'end' };
      }
      // Body
      if (mx >= pxS - 5 && mx <= pxE + 5 && Math.abs(my - midY) < 35) {
        return { index: i, part: 'body' };
      }
    }
  }
  // Point objects
  for (let i = state.objects.length - 1; i >= 0; i--) {
    const obj = state.objects[i];
    if (obj.type === 'distributed' || obj.type === 'trapezoid') continue;
    const px = beamToPixelX(obj.x, canvas);
    if (Math.abs(mx - px) < HIT_RADIUS && Math.abs(my - by) < HIT_RADIUS + 45) {
      return { index: i, part: 'body' };
    }
  }
  return null;
}

beamCanvas.addEventListener('mousedown', (e) => {
  const rect = beamCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (e.button === 2) {
    const hit = hitTest(mx, my, beamCanvas);
    if (hit) { state.objects.splice(hit.index, 1); solveAndRender(); }
    return;
  }

  if (state.tool) {
    const bx = snapValue(pixelToBeamX(mx, beamCanvas));
    if (state.tool === 'support') {
      state.objects.push({ type: 'support', x: bx, subtype: 'pinned', _id: newId() });
      setTool(null); solveAndRender();
    } else if (state.tool === 'load') {
      state.objects.push({ type: 'load', x: bx, value: 10000, angle: 0, _id: newId() });
      setTool(null); solveAndRender();
    } else if (state.tool === 'moment') {
      state.objects.push({ type: 'moment', x: bx, value: 1000000, _id: newId() });
      setTool(null); solveAndRender();
    } else if (state.tool === 'distributed' || state.tool === 'trapezoid') {
      if (state.distStart === null) {
        state.distStart = bx;
        renderAll();
      } else {
        const x1 = Math.min(state.distStart, bx);
        const x2 = Math.max(state.distStart, bx);
        if (x2 - x1 > 10) {
          if (state.tool === 'distributed') {
            state.objects.push({ type: 'distributed', x: x1, x2, value: 5, _id: newId() });
          } else {
            state.objects.push({ type: 'trapezoid', x: x1, x2, value: 8, value2: 0, _id: newId() });
          }
        }
        state.distStart = null;
        setTool(null); solveAndRender();
      }
    }
    return;
  }

  const hit = hitTest(mx, my, beamCanvas);
  if (hit) {
    const obj = state.objects[hit.index];
    if (hit.part === 'body' && (obj.type === 'distributed' || obj.type === 'trapezoid')) {
      const loadLen = obj.x2 - obj.x;
      dragging = { index: hit.index, part: 'body', offsetX: pixelToBeamX(mx, beamCanvas) - obj.x, origLen: loadLen };
    } else if (hit.part === 'start') {
      dragging = { index: hit.index, part: 'start', offsetX: 0 };
    } else if (hit.part === 'end') {
      dragging = { index: hit.index, part: 'end', offsetX: 0 };
    } else {
      dragging = { index: hit.index, part: 'body', offsetX: mx - beamToPixelX(obj.x, beamCanvas) };
    }
    beamCanvas.style.cursor = 'grabbing';
  }
});

beamCanvas.addEventListener('mousemove', (e) => {
  const rect = beamCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (dragging) {
    const obj = state.objects[dragging.index];
    if (!obj) { dragging = null; return; }

    if (obj.type === 'distributed' || obj.type === 'trapezoid') {
      if (dragging.part === 'body') {
        let newX = snapValue(pixelToBeamX(mx, beamCanvas) - dragging.offsetX);
        newX = Math.max(0, Math.min(state.beam.length - dragging.origLen, newX));
        obj.x = newX;
        obj.x2 = newX + dragging.origLen;
      } else if (dragging.part === 'start') {
        let newX = snapValue(pixelToBeamX(mx, beamCanvas));
        newX = Math.max(0, Math.min(obj.x2 - 10, newX));
        obj.x = newX;
      } else if (dragging.part === 'end') {
        let newX = snapValue(pixelToBeamX(mx, beamCanvas));
        newX = Math.max(obj.x + 10, Math.min(state.beam.length, newX));
        obj.x2 = newX;
      }
    } else {
      const bx = snapValue(pixelToBeamX(mx - dragging.offsetX, beamCanvas));
      obj.x = bx;
    }
    solveAndRender();
    return;
  }

  const hit = hitTest(mx, my, beamCanvas);
  const newHover = hit ? hit.index : -1;
  const newPart = hit ? hit.part : null;
  if (newHover !== hovering || newPart !== hoverPart) {
    hovering = newHover;
    hoverPart = newPart;
    if (hit) {
      beamCanvas.style.cursor = (hit.part === 'start' || hit.part === 'end') ? 'ew-resize' : 'grab';
    } else {
      beamCanvas.style.cursor = state.tool ? 'crosshair' : 'default';
    }
    renderAll();
  }
});

beamCanvas.addEventListener('mouseup', () => {
  if (dragging) { dragging = null; beamCanvas.style.cursor = hovering >= 0 ? 'grab' : 'default'; }
});
beamCanvas.addEventListener('mouseleave', () => {
  dragging = null; hovering = -1; hoverPart = null;
  beamCanvas.style.cursor = 'default'; renderAll();
});
beamCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

// ===== INLINE EDITING (double-click on labels) =====
beamCanvas.addEventListener('dblclick', (e) => {
  const rect = beamCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const hit = hitTest(mx, my, beamCanvas);
  if (!hit) return;

  const obj = state.objects[hit.index];
  const overlay = document.getElementById('inline-edit');
  const input = document.getElementById('inline-input');

  let currentVal;
  if (obj.type === 'load') currentVal = obj.value;
  else if (obj.type === 'moment') currentVal = obj.value;
  else if (obj.type === 'distributed') currentVal = obj.value;
  else if (obj.type === 'trapezoid') currentVal = obj.value;
  else return;

  overlay.style.display = 'block';
  overlay.style.left = (e.clientX - 45) + 'px';
  overlay.style.top = (e.clientY - 15) + 'px';
  input.value = currentVal;
  input.focus();
  input.select();

  const commit = () => {
    const newVal = parseFloat(input.value);
    if (!isNaN(newVal)) {
      if (obj.type === 'load' || obj.type === 'moment' || obj.type === 'distributed') {
        obj.value = newVal;
      } else if (obj.type === 'trapezoid') {
        obj.value = newVal;
      }
      solveAndRender();
    }
    overlay.style.display = 'none';
    input.removeEventListener('blur', commit);
    input.removeEventListener('keydown', onKey);
  };
  const onKey = (ev) => {
    if (ev.key === 'Enter') commit();
    if (ev.key === 'Escape') { overlay.style.display = 'none'; input.removeEventListener('blur', commit); input.removeEventListener('keydown', onKey); }
  };
  input.addEventListener('blur', commit);
  input.addEventListener('keydown', onKey);
});

// =============================================================================
// UI HELPERS
// =============================================================================
function setTool(tool) {
  state.tool = tool;
  state.distStart = null;
  ['btn-add-support','btn-add-load','btn-add-moment','btn-add-dist','btn-add-trap'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.remove('active');
  });
  const map = { support: 'btn-add-support', load: 'btn-add-load', moment: 'btn-add-moment', distributed: 'btn-add-dist', trapezoid: 'btn-add-trap' };
  if (tool && map[tool]) document.getElementById(map[tool]).classList.add('active');
  beamCanvas.style.cursor = tool ? 'crosshair' : 'default';
  renderAll();
}

function solveAndRender() { solveBeam(); renderAll(); }

function updateStats() {
  const r = state.result;
  document.getElementById('stat-v').textContent = r ? formatForce(r.maxV) : '—';
  document.getElementById('stat-m').textContent = r ? formatValue(r.maxM) + ' N·mm' : '—';
  document.getElementById('stat-n').textContent = r ? formatForce(r.maxN) : '—';
  document.getElementById('stat-w').textContent = r ? r.maxW.toFixed(4) + ' mm' : '—';
}

function updateObjectLists() {
  const supList = document.getElementById('support-list');
  const loadList = document.getElementById('load-list');
  supList.innerHTML = '';
  loadList.innerHTML = '';

  state.objects.forEach((obj, idx) => {
    const div = document.createElement('div');
    div.className = 'obj-item';

    if (obj.type === 'support') {
      div.innerHTML = `
        <div class="obj-icon" style="background:var(--support-color)"></div>
        <span class="obj-text">${obj.subtype} @ ${obj.x.toFixed(0)}</span>
        <select style="width:58px" onchange="changeSubtype(${idx},this.value)">
          <option value="pinned" ${obj.subtype==='pinned'?'selected':''}>Pin</option>
          <option value="roller" ${obj.subtype==='roller'?'selected':''}>Roller</option>
          <option value="fixed" ${obj.subtype==='fixed'?'selected':''}>Fixed</option>
        </select>
        <input type="number" value="${obj.x.toFixed(0)}" style="width:50px" onchange="changePosObj(${idx},this.value)">
        <span style="font-size:9px;color:var(--text-tertiary)">mm</span>
        <span class="obj-del" onclick="removeObj(${idx})">×</span>`;
      supList.appendChild(div);
    } else if (obj.type === 'load') {
      div.innerHTML = `
        <div class="obj-icon" style="background:var(--load-color)"></div>
        <span class="obj-text">${formatForce(Math.abs(obj.value))}</span>
        <input type="number" value="${obj.value}" style="width:55px" onchange="changeLoadValue(${idx},this.value)">
        <span class="obj-del" onclick="removeObj(${idx})">×</span>
        <div class="obj-row2">
          <label>Pos</label><input type="number" value="${obj.x.toFixed(0)}" style="width:48px" onchange="changePosObj(${idx},this.value)"><span style="font-size:9px;color:var(--text-tertiary)">mm</span>
          <label>Angle</label><input type="number" value="${obj.angle||0}" step="5" style="width:40px" onchange="changeAngle(${idx},this.value)"><span style="font-size:9px;color:var(--text-tertiary)">°</span>
        </div>`;
      loadList.appendChild(div);
    } else if (obj.type === 'moment') {
      div.innerHTML = `
        <div class="obj-icon" style="background:var(--moment-load-color)"></div>
        <span class="obj-text">Moment</span>
        <input type="number" value="${obj.value}" style="width:65px" onchange="changeMomentValue(${idx},this.value)">
        <span class="obj-del" onclick="removeObj(${idx})">×</span>
        <div class="obj-row2">
          <label>Pos</label><input type="number" value="${obj.x.toFixed(0)}" style="width:48px" onchange="changePosObj(${idx},this.value)"><span style="font-size:9px;color:var(--text-tertiary)">mm</span>
        </div>`;
      loadList.appendChild(div);
    } else if (obj.type === 'distributed') {
      div.innerHTML = `
        <div class="obj-icon" style="background:var(--load-color)"></div>
        <span class="obj-text">UDL ${obj.value.toFixed(1)} N/mm</span>
        <input type="number" value="${obj.value}" step="0.5" style="width:50px" onchange="changeDistValue(${idx},this.value)">
        <span class="obj-del" onclick="removeObj(${idx})">×</span>
        <div class="obj-row2">
          <label>Start</label><input type="number" value="${obj.x.toFixed(0)}" style="width:48px" onchange="changeDistStart(${idx},this.value)">
          <label>End</label><input type="number" value="${obj.x2.toFixed(0)}" style="width:48px" onchange="changeDistEnd(${idx},this.value)">
        </div>`;
      loadList.appendChild(div);
    } else if (obj.type === 'trapezoid') {
      div.innerHTML = `
        <div class="obj-icon" style="background:var(--load-color)"></div>
        <span class="obj-text">Trap ${obj.value.toFixed(1)}→${obj.value2.toFixed(1)}</span>
        <span class="obj-del" onclick="removeObj(${idx})">×</span>
        <div class="obj-row2">
          <label>q₁</label><input type="number" value="${obj.value}" step="0.5" style="width:45px" onchange="changeTrapQ1(${idx},this.value)">
          <label>q₂</label><input type="number" value="${obj.value2}" step="0.5" style="width:45px" onchange="changeTrapQ2(${idx},this.value)">
        </div>
        <div class="obj-row2">
          <label>Start</label><input type="number" value="${obj.x.toFixed(0)}" style="width:45px" onchange="changeDistStart(${idx},this.value)">
          <label>End</label><input type="number" value="${obj.x2.toFixed(0)}" style="width:45px" onchange="changeDistEnd(${idx},this.value)">
        </div>`;
      loadList.appendChild(div);
    }
  });
}

function removeObj(idx) { state.objects.splice(idx, 1); solveAndRender(); }
function changeSubtype(idx, val) { state.objects[idx].subtype = val; solveAndRender(); }
function changeLoadValue(idx, val) { state.objects[idx].value = parseFloat(val)||0; solveAndRender(); }
function changeMomentValue(idx, val) { state.objects[idx].value = parseFloat(val)||0; solveAndRender(); }
function changeAngle(idx, val) { state.objects[idx].angle = parseFloat(val)||0; solveAndRender(); }
function changeDistValue(idx, val) { state.objects[idx].value = parseFloat(val)||0; solveAndRender(); }
function changeDistStart(idx, val) { state.objects[idx].x = Math.max(0, parseFloat(val)||0); solveAndRender(); }
function changeDistEnd(idx, val) { state.objects[idx].x2 = Math.min(state.beam.length, parseFloat(val)||0); solveAndRender(); }
function changeTrapQ1(idx, val) { state.objects[idx].value = parseFloat(val)||0; solveAndRender(); }
function changeTrapQ2(idx, val) { state.objects[idx].value2 = parseFloat(val)||0; solveAndRender(); }
function changePosObj(idx, val) {
  const v = Math.max(0, Math.min(state.beam.length, parseFloat(val)||0));
  state.objects[idx].x = v;
  solveAndRender();
}

function applyBeamProps() {
  state.beam.length = parseFloat(document.getElementById('inp-length').value) || 5000;
  state.beam.E = parseFloat(document.getElementById('inp-E').value) || 210000;
  state.beam.I = parseFloat(document.getElementById('inp-I').value) || 83560000;
  state.beam.A = parseFloat(document.getElementById('inp-A').value) || 2850;
  solveAndRender();
}

function clearAll() {
  state.objects = []; state.result = null;
  setTool(null); solveAndRender();
  document.getElementById('status-text').textContent = 'Cleared';
}

// ===== PRESETS =====
function loadPreset(name) {
  state.objects = []; state.result = null; setTool(null);

  if (name === 'simply_supported') {
    state.beam = { length: 5000, E: 210000, I: 83560000, A: 2850 };
    state.objects = [
      { type: 'support', x: 0, subtype: 'pinned', _id: newId() },
      { type: 'support', x: 5000, subtype: 'roller', _id: newId() },
      { type: 'load', x: 2500, value: 10000, angle: 0, _id: newId() },
    ];
  } else if (name === 'cantilever') {
    state.beam = { length: 3000, E: 210000, I: 83560000, A: 2850 };
    state.objects = [
      { type: 'support', x: 0, subtype: 'fixed', _id: newId() },
      { type: 'load', x: 3000, value: 5000, angle: 0, _id: newId() },
    ];
  } else if (name === 'continuous') {
    state.beam = { length: 9000, E: 210000, I: 83560000, A: 2850 };
    state.objects = [
      { type: 'support', x: 0, subtype: 'pinned', _id: newId() },
      { type: 'support', x: 3000, subtype: 'roller', _id: newId() },
      { type: 'support', x: 6000, subtype: 'roller', _id: newId() },
      { type: 'support', x: 9000, subtype: 'roller', _id: newId() },
      { type: 'trapezoid', x: 0, x2: 9000, value: 8, value2: 2, _id: newId() },
    ];
  } else if (name === 'angled') {
    state.beam = { length: 6000, E: 210000, I: 83560000, A: 2850 };
    state.objects = [
      { type: 'support', x: 0, subtype: 'pinned', _id: newId() },
      { type: 'support', x: 6000, subtype: 'roller', _id: newId() },
      { type: 'load', x: 2000, value: 8000, angle: 30, _id: newId() },
      { type: 'load', x: 4000, value: 6000, angle: -45, _id: newId() },
      { type: 'moment', x: 3000, value: 2000000, _id: newId() },
    ];
  }

  document.getElementById('inp-length').value = state.beam.length;
  document.getElementById('inp-E').value = state.beam.E;
  document.getElementById('inp-I').value = state.beam.I;
  document.getElementById('inp-A').value = state.beam.A;

  solveAndRender();
  document.getElementById('status-text').textContent = 'Loaded: ' + name.replace(/_/g, ' ');
}

// ===== INIT =====
function init() { resizeCanvases(); loadPreset('simply_supported'); }
window.addEventListener('resize', () => { resizeCanvases(); renderAll(); });
['inp-length','inp-E','inp-I','inp-A'].forEach(id => {
  document.getElementById(id).addEventListener('keydown', (e) => { if (e.key === 'Enter') applyBeamProps(); });
});
init();
</script>
</body>
</html>
